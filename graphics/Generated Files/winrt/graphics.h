// WARNING: Please don't edit this file. It was generated by C++/WinRT v1.0.180821.2

#pragma once

#include "winrt/base.h"


static_assert(winrt::check_version(CPPWINRT_VERSION, "1.0.180821.2"), "Mismatched component and base headers.");
#include "winrt/Windows.Foundation.h"
#include "winrt/Windows.Foundation.Collections.h"
#include "winrt/impl/Windows.UI.Xaml.Controls.2.h"
#include "winrt/impl/Windows.UI.Xaml.Data.2.h"
#include "winrt/impl/graphics.2.h"

namespace winrt::impl {

template <typename D> graphics::view consume_graphics_Ibuffer<D>::get_view() const
{
    graphics::view result{};
    check_hresult(WINRT_SHIM(graphics::Ibuffer)->get_view(put_abi(result)));
    return result;
}

template <typename D> int32_t consume_graphics_Ibuffer<D>::get_capacity_percentage() const
{
    int32_t result{};
    check_hresult(WINRT_SHIM(graphics::Ibuffer)->get_capacity_percentage(&result));
    return result;
}

template <typename D> void consume_graphics_Ibuffer<D>::add_to_view(graphics::vertex const& new_vertex) const
{
    check_hresult(WINRT_SHIM(graphics::Ibuffer)->add_to_view(get_abi(new_vertex)));
}

template <typename D> void consume_graphics_Ibuffer<D>::clear() const
{
    check_hresult(WINRT_SHIM(graphics::Ibuffer)->clear());
}

template <typename D> int32_t consume_graphics_Ibuffer<D>::max_size() const
{
    int32_t value{};
    check_hresult(WINRT_SHIM(graphics::Ibuffer)->get_max_size(&value));
    return value;
}

template <typename D> void consume_graphics_Ibuffer<D>::max_size(int32_t value) const
{
    check_hresult(WINRT_SHIM(graphics::Ibuffer)->put_max_size(value));
}

template <typename D> int32_t consume_graphics_Ibuffer<D>::current_size() const
{
    int32_t value{};
    check_hresult(WINRT_SHIM(graphics::Ibuffer)->get_current_size(&value));
    return value;
}

template <typename D> void consume_graphics_Ibuffer<D>::current_size(int32_t value) const
{
    check_hresult(WINRT_SHIM(graphics::Ibuffer)->put_current_size(value));
}

template <typename D> int32_t consume_graphics_Ibuffer<D>::resize_increment() const
{
    int32_t value{};
    check_hresult(WINRT_SHIM(graphics::Ibuffer)->get_resize_increment(&value));
    return value;
}

template <typename D> void consume_graphics_Ibuffer<D>::resize_increment(int32_t value) const
{
    check_hresult(WINRT_SHIM(graphics::Ibuffer)->put_resize_increment(value));
}

template <typename D> bool consume_graphics_Ibuffer<D>::is_auto_resize() const
{
    bool value{};
    check_hresult(WINRT_SHIM(graphics::Ibuffer)->get_is_auto_resize(&value));
    return value;
}

template <typename D> bool consume_graphics_Ibuffer<D>::is_buffer_full() const
{
    bool value{};
    check_hresult(WINRT_SHIM(graphics::Ibuffer)->get_is_buffer_full(&value));
    return value;
}

template <typename D> graphics::buffer consume_graphics_IbufferFactory<D>::CreateInstance(graphics::buffer_type const& type, Windows::Foundation::Collections::IObservableVector<graphics::vertex> const& initial_data, int32_t max_size, int32_t resize_increment, bool is_auto_resize) const
{
    graphics::buffer value{ nullptr };
    check_hresult(WINRT_SHIM(graphics::IbufferFactory)->CreateInstance(get_abi(type), get_abi(initial_data), max_size, resize_increment, is_auto_resize, put_abi(value)));
    return value;
}

template <typename D> void consume_graphics_Irenderer<D>::enable_debug_layer() const
{
    check_hresult(WINRT_SHIM(graphics::Irenderer)->enable_debug_layer());
}

template <typename D> void consume_graphics_Irenderer<D>::initialize(Windows::UI::Xaml::Controls::SwapChainPanel const& target_swapchain) const
{
    check_hresult(WINRT_SHIM(graphics::Irenderer)->initialize(get_abi(target_swapchain)));
}

template <typename D> void consume_graphics_Irenderer<D>::start_render_loop() const
{
    check_hresult(WINRT_SHIM(graphics::Irenderer)->start_render_loop());
}

template <typename D> void consume_graphics_Irenderer<D>::stop_render_loop() const
{
    check_hresult(WINRT_SHIM(graphics::Irenderer)->stop_render_loop());
}

template <typename D> bool consume_graphics_Irenderer<D>::is_rendering() const
{
    bool value{};
    check_hresult(WINRT_SHIM(graphics::Irenderer)->get_is_rendering(&value));
    return value;
}

template <typename D> graphics::primitive_types consume_graphics_Irenderer<D>::current_topology() const
{
    graphics::primitive_types value{};
    check_hresult(WINRT_SHIM(graphics::Irenderer)->get_current_topology(put_abi(value)));
    return value;
}

template <typename D> void consume_graphics_Irenderer<D>::current_topology(graphics::primitive_types const& value) const
{
    check_hresult(WINRT_SHIM(graphics::Irenderer)->put_current_topology(get_abi(value)));
}

template <typename D> Windows::Foundation::IAsyncOperation<graphics::compilation_result> consume_graphics_Irenderer<D>::pick_and_compile_shader(param::hstring const& shader_name, param::hstring const& entry_point, param::hstring const& version) const
{
    Windows::Foundation::IAsyncOperation<graphics::compilation_result> operation{ nullptr };
    check_hresult(WINRT_SHIM(graphics::Irenderer)->pick_and_compile_shader(get_abi(shader_name), get_abi(entry_point), get_abi(version), put_abi(operation)));
    return operation;
}

template <typename D> graphics::buffer consume_graphics_Irenderer<D>::current_buffer() const
{
    graphics::buffer value{ nullptr };
    check_hresult(WINRT_SHIM(graphics::Irenderer)->get_current_buffer(put_abi(value)));
    return value;
}

template <typename D> void consume_graphics_Irenderer<D>::current_buffer(graphics::buffer const& value) const
{
    check_hresult(WINRT_SHIM(graphics::Irenderer)->put_current_buffer(get_abi(value)));
}

template <typename D> hstring consume_graphics_Ishader<D>::shader_name() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(graphics::Ishader)->get_shader_name(put_abi(value)));
    return value;
}

template <typename D> void consume_graphics_Ishader<D>::shader_name(param::hstring const& value) const
{
    check_hresult(WINRT_SHIM(graphics::Ishader)->put_shader_name(get_abi(value)));
}

template <typename D> hstring consume_graphics_Ishader<D>::type_glyph() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(graphics::Ishader)->get_type_glyph(put_abi(value)));
    return value;
}

template <typename D> void consume_graphics_Ishader<D>::type_glyph(param::hstring const& value) const
{
    check_hresult(WINRT_SHIM(graphics::Ishader)->put_type_glyph(get_abi(value)));
}

template <typename D> bool consume_graphics_Ishader<D>::is_loading() const
{
    bool value{};
    check_hresult(WINRT_SHIM(graphics::Ishader)->get_is_loading(&value));
    return value;
}

template <typename D> void consume_graphics_Ishader<D>::is_loading(bool value) const
{
    check_hresult(WINRT_SHIM(graphics::Ishader)->put_is_loading(value));
}

template <typename D> bool consume_graphics_Ishader<D>::is_error() const
{
    bool value{};
    check_hresult(WINRT_SHIM(graphics::Ishader)->get_is_error(&value));
    return value;
}

template <typename D> void consume_graphics_Ishader<D>::is_error(bool value) const
{
    check_hresult(WINRT_SHIM(graphics::Ishader)->put_is_error(value));
}

template <typename D> graphics::shader_type consume_graphics_Ishader<D>::shader_type() const
{
    graphics::shader_type value{};
    check_hresult(WINRT_SHIM(graphics::Ishader)->get_shader_type(put_abi(value)));
    return value;
}

template <typename D> void consume_graphics_Ishader<D>::shader_type(graphics::shader_type const& value) const
{
    check_hresult(WINRT_SHIM(graphics::Ishader)->put_shader_type(get_abi(value)));
}

template <typename D> graphics::shader consume_graphics_IshaderFactory<D>::CreateInstance(param::hstring const& name, graphics::shader_type const& type) const
{
    graphics::shader value{ nullptr };
    check_hresult(WINRT_SHIM(graphics::IshaderFactory)->CreateInstance(get_abi(name), get_abi(type), put_abi(value)));
    return value;
}

template <typename D> float consume_graphics_Ivertex<D>::x() const
{
    float value{};
    check_hresult(WINRT_SHIM(graphics::Ivertex)->get_x(&value));
    return value;
}

template <typename D> void consume_graphics_Ivertex<D>::x(float value) const
{
    check_hresult(WINRT_SHIM(graphics::Ivertex)->put_x(value));
}

template <typename D> float consume_graphics_Ivertex<D>::y() const
{
    float value{};
    check_hresult(WINRT_SHIM(graphics::Ivertex)->get_y(&value));
    return value;
}

template <typename D> void consume_graphics_Ivertex<D>::y(float value) const
{
    check_hresult(WINRT_SHIM(graphics::Ivertex)->put_y(value));
}

template <typename D> float consume_graphics_Ivertex<D>::z() const
{
    float value{};
    check_hresult(WINRT_SHIM(graphics::Ivertex)->get_z(&value));
    return value;
}

template <typename D> void consume_graphics_Ivertex<D>::z(float value) const
{
    check_hresult(WINRT_SHIM(graphics::Ivertex)->put_z(value));
}

template <typename D> float consume_graphics_Ivertex<D>::r() const
{
    float value{};
    check_hresult(WINRT_SHIM(graphics::Ivertex)->get_r(&value));
    return value;
}

template <typename D> void consume_graphics_Ivertex<D>::r(float value) const
{
    check_hresult(WINRT_SHIM(graphics::Ivertex)->put_r(value));
}

template <typename D> float consume_graphics_Ivertex<D>::g() const
{
    float value{};
    check_hresult(WINRT_SHIM(graphics::Ivertex)->get_g(&value));
    return value;
}

template <typename D> void consume_graphics_Ivertex<D>::g(float value) const
{
    check_hresult(WINRT_SHIM(graphics::Ivertex)->put_g(value));
}

template <typename D> float consume_graphics_Ivertex<D>::b() const
{
    float value{};
    check_hresult(WINRT_SHIM(graphics::Ivertex)->get_b(&value));
    return value;
}

template <typename D> void consume_graphics_Ivertex<D>::b(float value) const
{
    check_hresult(WINRT_SHIM(graphics::Ivertex)->put_b(value));
}

template <typename D> float consume_graphics_Ivertex<D>::a() const
{
    float value{};
    check_hresult(WINRT_SHIM(graphics::Ivertex)->get_a(&value));
    return value;
}

template <typename D> void consume_graphics_Ivertex<D>::a(float value) const
{
    check_hresult(WINRT_SHIM(graphics::Ivertex)->put_a(value));
}

template <typename D> float consume_graphics_Ivertex<D>::u() const
{
    float value{};
    check_hresult(WINRT_SHIM(graphics::Ivertex)->get_u(&value));
    return value;
}

template <typename D> void consume_graphics_Ivertex<D>::u(float value) const
{
    check_hresult(WINRT_SHIM(graphics::Ivertex)->put_u(value));
}

template <typename D> float consume_graphics_Ivertex<D>::v() const
{
    float value{};
    check_hresult(WINRT_SHIM(graphics::Ivertex)->get_v(&value));
    return value;
}

template <typename D> void consume_graphics_Ivertex<D>::v(float value) const
{
    check_hresult(WINRT_SHIM(graphics::Ivertex)->put_v(value));
}

template <typename D> graphics::vertex consume_graphics_IvertexFactory<D>::CreateInstance(float x, float y, float z, float r, float g, float b, float a, float u, float v) const
{
    graphics::vertex value{ nullptr };
    check_hresult(WINRT_SHIM(graphics::IvertexFactory)->CreateInstance(x, y, z, r, g, b, a, u, v, put_abi(value)));
    return value;
}

template <typename D>
struct produce<D, graphics::Ibuffer> : produce_base<D, graphics::Ibuffer>
{
    int32_t WINRT_CALL get_view(struct struct_graphics_view* result) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(get_view, WINRT_WRAP(graphics::view));
            *result = detach_from<graphics::view>(this->shim().get_view());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_capacity_percentage(int32_t* result) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(get_capacity_percentage, WINRT_WRAP(int32_t));
            *result = detach_from<int32_t>(this->shim().get_capacity_percentage());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL add_to_view(void* new_vertex) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(add_to_view, WINRT_WRAP(void), graphics::vertex const&);
            this->shim().add_to_view(*reinterpret_cast<graphics::vertex const*>(&new_vertex));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL clear() noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(clear, WINRT_WRAP(void));
            this->shim().clear();
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_max_size(int32_t* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(max_size, WINRT_WRAP(int32_t));
            *value = detach_from<int32_t>(this->shim().max_size());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_max_size(int32_t value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(max_size, WINRT_WRAP(void), int32_t);
            this->shim().max_size(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_current_size(int32_t* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(current_size, WINRT_WRAP(int32_t));
            *value = detach_from<int32_t>(this->shim().current_size());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_current_size(int32_t value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(current_size, WINRT_WRAP(void), int32_t);
            this->shim().current_size(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_resize_increment(int32_t* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(resize_increment, WINRT_WRAP(int32_t));
            *value = detach_from<int32_t>(this->shim().resize_increment());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_resize_increment(int32_t value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(resize_increment, WINRT_WRAP(void), int32_t);
            this->shim().resize_increment(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_is_auto_resize(bool* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(is_auto_resize, WINRT_WRAP(bool));
            *value = detach_from<bool>(this->shim().is_auto_resize());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_is_buffer_full(bool* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(is_buffer_full, WINRT_WRAP(bool));
            *value = detach_from<bool>(this->shim().is_buffer_full());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, graphics::IbufferFactory> : produce_base<D, graphics::IbufferFactory>
{
    int32_t WINRT_CALL CreateInstance(graphics::buffer_type type, void* initial_data, int32_t max_size, int32_t resize_increment, bool is_auto_resize, void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateInstance, WINRT_WRAP(graphics::buffer), graphics::buffer_type const&, Windows::Foundation::Collections::IObservableVector<graphics::vertex> const&, int32_t, int32_t, bool);
            *value = detach_from<graphics::buffer>(this->shim().CreateInstance(*reinterpret_cast<graphics::buffer_type const*>(&type), *reinterpret_cast<Windows::Foundation::Collections::IObservableVector<graphics::vertex> const*>(&initial_data), max_size, resize_increment, is_auto_resize));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, graphics::Irenderer> : produce_base<D, graphics::Irenderer>
{
    int32_t WINRT_CALL enable_debug_layer() noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(enable_debug_layer, WINRT_WRAP(void));
            this->shim().enable_debug_layer();
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL initialize(void* target_swapchain) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(initialize, WINRT_WRAP(void), Windows::UI::Xaml::Controls::SwapChainPanel const&);
            this->shim().initialize(*reinterpret_cast<Windows::UI::Xaml::Controls::SwapChainPanel const*>(&target_swapchain));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL start_render_loop() noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(start_render_loop, WINRT_WRAP(void));
            this->shim().start_render_loop();
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL stop_render_loop() noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(stop_render_loop, WINRT_WRAP(void));
            this->shim().stop_render_loop();
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_is_rendering(bool* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(is_rendering, WINRT_WRAP(bool));
            *value = detach_from<bool>(this->shim().is_rendering());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_current_topology(graphics::primitive_types* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(current_topology, WINRT_WRAP(graphics::primitive_types));
            *value = detach_from<graphics::primitive_types>(this->shim().current_topology());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_current_topology(graphics::primitive_types value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(current_topology, WINRT_WRAP(void), graphics::primitive_types const&);
            this->shim().current_topology(*reinterpret_cast<graphics::primitive_types const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL pick_and_compile_shader(void* shader_name, void* entry_point, void* version, void** operation) noexcept final
    {
        try
        {
            *operation = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(pick_and_compile_shader, WINRT_WRAP(Windows::Foundation::IAsyncOperation<graphics::compilation_result>), hstring const&, hstring const&, hstring const&);
            *operation = detach_from<Windows::Foundation::IAsyncOperation<graphics::compilation_result>>(this->shim().pick_and_compile_shader(*reinterpret_cast<hstring const*>(&shader_name), *reinterpret_cast<hstring const*>(&entry_point), *reinterpret_cast<hstring const*>(&version)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_current_buffer(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(current_buffer, WINRT_WRAP(graphics::buffer));
            *value = detach_from<graphics::buffer>(this->shim().current_buffer());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_current_buffer(void* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(current_buffer, WINRT_WRAP(void), graphics::buffer const&);
            this->shim().current_buffer(*reinterpret_cast<graphics::buffer const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, graphics::Ishader> : produce_base<D, graphics::Ishader>
{
    int32_t WINRT_CALL get_shader_name(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(shader_name, WINRT_WRAP(hstring));
            *value = detach_from<hstring>(this->shim().shader_name());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_shader_name(void* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(shader_name, WINRT_WRAP(void), hstring const&);
            this->shim().shader_name(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_type_glyph(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(type_glyph, WINRT_WRAP(hstring));
            *value = detach_from<hstring>(this->shim().type_glyph());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_type_glyph(void* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(type_glyph, WINRT_WRAP(void), hstring const&);
            this->shim().type_glyph(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_is_loading(bool* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(is_loading, WINRT_WRAP(bool));
            *value = detach_from<bool>(this->shim().is_loading());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_is_loading(bool value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(is_loading, WINRT_WRAP(void), bool);
            this->shim().is_loading(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_is_error(bool* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(is_error, WINRT_WRAP(bool));
            *value = detach_from<bool>(this->shim().is_error());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_is_error(bool value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(is_error, WINRT_WRAP(void), bool);
            this->shim().is_error(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_shader_type(graphics::shader_type* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(shader_type, WINRT_WRAP(graphics::shader_type));
            *value = detach_from<graphics::shader_type>(this->shim().shader_type());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_shader_type(graphics::shader_type value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(shader_type, WINRT_WRAP(void), graphics::shader_type const&);
            this->shim().shader_type(*reinterpret_cast<graphics::shader_type const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, graphics::IshaderFactory> : produce_base<D, graphics::IshaderFactory>
{
    int32_t WINRT_CALL CreateInstance(void* name, graphics::shader_type type, void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateInstance, WINRT_WRAP(graphics::shader), hstring const&, graphics::shader_type const&);
            *value = detach_from<graphics::shader>(this->shim().CreateInstance(*reinterpret_cast<hstring const*>(&name), *reinterpret_cast<graphics::shader_type const*>(&type)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, graphics::Ivertex> : produce_base<D, graphics::Ivertex>
{
    int32_t WINRT_CALL get_x(float* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(x, WINRT_WRAP(float));
            *value = detach_from<float>(this->shim().x());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_x(float value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(x, WINRT_WRAP(void), float);
            this->shim().x(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_y(float* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(y, WINRT_WRAP(float));
            *value = detach_from<float>(this->shim().y());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_y(float value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(y, WINRT_WRAP(void), float);
            this->shim().y(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_z(float* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(z, WINRT_WRAP(float));
            *value = detach_from<float>(this->shim().z());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_z(float value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(z, WINRT_WRAP(void), float);
            this->shim().z(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_r(float* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(r, WINRT_WRAP(float));
            *value = detach_from<float>(this->shim().r());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_r(float value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(r, WINRT_WRAP(void), float);
            this->shim().r(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_g(float* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(g, WINRT_WRAP(float));
            *value = detach_from<float>(this->shim().g());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_g(float value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(g, WINRT_WRAP(void), float);
            this->shim().g(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_b(float* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(b, WINRT_WRAP(float));
            *value = detach_from<float>(this->shim().b());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_b(float value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(b, WINRT_WRAP(void), float);
            this->shim().b(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_a(float* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(a, WINRT_WRAP(float));
            *value = detach_from<float>(this->shim().a());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_a(float value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(a, WINRT_WRAP(void), float);
            this->shim().a(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_u(float* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(u, WINRT_WRAP(float));
            *value = detach_from<float>(this->shim().u());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_u(float value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(u, WINRT_WRAP(void), float);
            this->shim().u(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_v(float* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(v, WINRT_WRAP(float));
            *value = detach_from<float>(this->shim().v());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_v(float value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(v, WINRT_WRAP(void), float);
            this->shim().v(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, graphics::IvertexFactory> : produce_base<D, graphics::IvertexFactory>
{
    int32_t WINRT_CALL CreateInstance(float x, float y, float z, float r, float g, float b, float a, float u, float v, void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateInstance, WINRT_WRAP(graphics::vertex), float, float, float, float, float, float, float, float, float);
            *value = detach_from<graphics::vertex>(this->shim().CreateInstance(x, y, z, r, g, b, a, u, v));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

}

WINRT_EXPORT namespace winrt::graphics {

inline buffer::buffer() :
    buffer(impl::call_factory<buffer>([](auto&& f) { return f.template ActivateInstance<buffer>(); }))
{}

inline buffer::buffer(graphics::buffer_type const& type, Windows::Foundation::Collections::IObservableVector<graphics::vertex> const& initial_data, int32_t max_size, int32_t resize_increment, bool is_auto_resize) :
    buffer(impl::call_factory<buffer, graphics::IbufferFactory>([&](auto&& f) { return f.CreateInstance(type, initial_data, max_size, resize_increment, is_auto_resize); }))
{}

inline renderer::renderer() :
    renderer(impl::call_factory<renderer>([](auto&& f) { return f.template ActivateInstance<renderer>(); }))
{}

inline shader::shader(param::hstring const& name, graphics::shader_type const& type) :
    shader(impl::call_factory<shader, graphics::IshaderFactory>([&](auto&& f) { return f.CreateInstance(name, type); }))
{}

inline vertex::vertex() :
    vertex(impl::call_factory<vertex>([](auto&& f) { return f.template ActivateInstance<vertex>(); }))
{}

inline vertex::vertex(float x, float y, float z, float r, float g, float b, float a, float u, float v) :
    vertex(impl::call_factory<vertex, graphics::IvertexFactory>([&](auto&& f) { return f.CreateInstance(x, y, z, r, g, b, a, u, v); }))
{}

}

namespace winrt::impl {

struct property_graphics_Ibuffer
{ struct named {
    struct current_size
    {
        struct name { static constexpr std::wstring_view value{ L"current_size"sv }; };
        using property_type = int32_t;
        using target_type = winrt::graphics::Ibuffer;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.current_size();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.current_size(std::forward<Value>(value));
            }
        };
    };
    struct is_auto_resize
    {
        struct name { static constexpr std::wstring_view value{ L"is_auto_resize"sv }; };
        using property_type = bool;
        using target_type = winrt::graphics::Ibuffer;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.is_auto_resize();
            }
        };
    };
    struct is_buffer_full
    {
        struct name { static constexpr std::wstring_view value{ L"is_buffer_full"sv }; };
        using property_type = bool;
        using target_type = winrt::graphics::Ibuffer;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.is_buffer_full();
            }
        };
    };
    struct max_size
    {
        struct name { static constexpr std::wstring_view value{ L"max_size"sv }; };
        using property_type = int32_t;
        using target_type = winrt::graphics::Ibuffer;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.max_size();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.max_size(std::forward<Value>(value));
            }
        };
    };
    struct resize_increment
    {
        struct name { static constexpr std::wstring_view value{ L"resize_increment"sv }; };
        using property_type = int32_t;
        using target_type = winrt::graphics::Ibuffer;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.resize_increment();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.resize_increment(std::forward<Value>(value));
            }
        };
    };};
    struct list { using type = impl::typelist<named::current_size, named::is_auto_resize, named::is_buffer_full, named::max_size, named::resize_increment>; };
};

struct property_graphics_Irenderer
{ struct named {
    struct current_buffer
    {
        struct name { static constexpr std::wstring_view value{ L"current_buffer"sv }; };
        using property_type = winrt::graphics::buffer;
        using target_type = winrt::graphics::Irenderer;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.current_buffer();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.current_buffer(std::forward<Value>(value));
            }
        };
    };
    struct current_topology
    {
        struct name { static constexpr std::wstring_view value{ L"current_topology"sv }; };
        using property_type = winrt::graphics::primitive_types;
        using target_type = winrt::graphics::Irenderer;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.current_topology();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.current_topology(std::forward<Value>(value));
            }
        };
    };
    struct is_rendering
    {
        struct name { static constexpr std::wstring_view value{ L"is_rendering"sv }; };
        using property_type = bool;
        using target_type = winrt::graphics::Irenderer;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.is_rendering();
            }
        };
    };};
    struct list { using type = impl::typelist<named::current_buffer, named::current_topology, named::is_rendering>; };
};

struct property_graphics_Ishader
{ struct named {
    struct is_error
    {
        struct name { static constexpr std::wstring_view value{ L"is_error"sv }; };
        using property_type = bool;
        using target_type = winrt::graphics::Ishader;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.is_error();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.is_error(std::forward<Value>(value));
            }
        };
    };
    struct is_loading
    {
        struct name { static constexpr std::wstring_view value{ L"is_loading"sv }; };
        using property_type = bool;
        using target_type = winrt::graphics::Ishader;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.is_loading();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.is_loading(std::forward<Value>(value));
            }
        };
    };
    struct shader_name
    {
        struct name { static constexpr std::wstring_view value{ L"shader_name"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::graphics::Ishader;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.shader_name();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.shader_name(std::forward<Value>(value));
            }
        };
    };
    struct shader_type
    {
        struct name { static constexpr std::wstring_view value{ L"shader_type"sv }; };
        using property_type = winrt::graphics::shader_type;
        using target_type = winrt::graphics::Ishader;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.shader_type();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.shader_type(std::forward<Value>(value));
            }
        };
    };
    struct type_glyph
    {
        struct name { static constexpr std::wstring_view value{ L"type_glyph"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::graphics::Ishader;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.type_glyph();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.type_glyph(std::forward<Value>(value));
            }
        };
    };};
    struct list { using type = impl::typelist<named::is_error, named::is_loading, named::shader_name, named::shader_type, named::type_glyph>; };
};

struct property_graphics_Ivertex
{ struct named {
    struct a
    {
        struct name { static constexpr std::wstring_view value{ L"a"sv }; };
        using property_type = float;
        using target_type = winrt::graphics::Ivertex;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.a();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.a(std::forward<Value>(value));
            }
        };
    };
    struct b
    {
        struct name { static constexpr std::wstring_view value{ L"b"sv }; };
        using property_type = float;
        using target_type = winrt::graphics::Ivertex;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.b();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.b(std::forward<Value>(value));
            }
        };
    };
    struct g
    {
        struct name { static constexpr std::wstring_view value{ L"g"sv }; };
        using property_type = float;
        using target_type = winrt::graphics::Ivertex;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.g();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.g(std::forward<Value>(value));
            }
        };
    };
    struct r
    {
        struct name { static constexpr std::wstring_view value{ L"r"sv }; };
        using property_type = float;
        using target_type = winrt::graphics::Ivertex;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.r();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.r(std::forward<Value>(value));
            }
        };
    };
    struct u
    {
        struct name { static constexpr std::wstring_view value{ L"u"sv }; };
        using property_type = float;
        using target_type = winrt::graphics::Ivertex;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.u();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.u(std::forward<Value>(value));
            }
        };
    };
    struct v
    {
        struct name { static constexpr std::wstring_view value{ L"v"sv }; };
        using property_type = float;
        using target_type = winrt::graphics::Ivertex;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.v();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.v(std::forward<Value>(value));
            }
        };
    };
    struct x
    {
        struct name { static constexpr std::wstring_view value{ L"x"sv }; };
        using property_type = float;
        using target_type = winrt::graphics::Ivertex;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.x();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.x(std::forward<Value>(value));
            }
        };
    };
    struct y
    {
        struct name { static constexpr std::wstring_view value{ L"y"sv }; };
        using property_type = float;
        using target_type = winrt::graphics::Ivertex;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.y();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.y(std::forward<Value>(value));
            }
        };
    };
    struct z
    {
        struct name { static constexpr std::wstring_view value{ L"z"sv }; };
        using property_type = float;
        using target_type = winrt::graphics::Ivertex;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.z();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.z(std::forward<Value>(value));
            }
        };
    };};
    struct list { using type = impl::typelist<named::a, named::b, named::g, named::r, named::u, named::v, named::x, named::y, named::z>; };
};

struct property_graphics_buffer
{ struct named {
    struct resize_increment
    {
        struct name { static constexpr std::wstring_view value{ L"resize_increment"sv }; };
        using property_type = int32_t;
        using target_type = winrt::graphics::buffer;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.resize_increment();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.resize_increment(std::forward<Value>(value));
            }
        };
    };
    struct max_size
    {
        struct name { static constexpr std::wstring_view value{ L"max_size"sv }; };
        using property_type = int32_t;
        using target_type = winrt::graphics::buffer;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.max_size();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.max_size(std::forward<Value>(value));
            }
        };
    };
    struct current_size
    {
        struct name { static constexpr std::wstring_view value{ L"current_size"sv }; };
        using property_type = int32_t;
        using target_type = winrt::graphics::buffer;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.current_size();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.current_size(std::forward<Value>(value));
            }
        };
    };
    struct is_auto_resize
    {
        struct name { static constexpr std::wstring_view value{ L"is_auto_resize"sv }; };
        using property_type = bool;
        using target_type = winrt::graphics::buffer;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.is_auto_resize();
            }
        };
    };
    struct is_buffer_full
    {
        struct name { static constexpr std::wstring_view value{ L"is_buffer_full"sv }; };
        using property_type = bool;
        using target_type = winrt::graphics::buffer;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.is_buffer_full();
            }
        };
    };};
    struct list { using type = impl::typelist<named::resize_increment, named::max_size, named::current_size, named::is_auto_resize, named::is_buffer_full>; };
};

struct property_graphics_renderer
{ struct named {
    struct current_topology
    {
        struct name { static constexpr std::wstring_view value{ L"current_topology"sv }; };
        using property_type = winrt::graphics::primitive_types;
        using target_type = winrt::graphics::renderer;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.current_topology();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.current_topology(std::forward<Value>(value));
            }
        };
    };
    struct current_buffer
    {
        struct name { static constexpr std::wstring_view value{ L"current_buffer"sv }; };
        using property_type = winrt::graphics::buffer;
        using target_type = winrt::graphics::renderer;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.current_buffer();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.current_buffer(std::forward<Value>(value));
            }
        };
    };
    struct is_rendering
    {
        struct name { static constexpr std::wstring_view value{ L"is_rendering"sv }; };
        using property_type = bool;
        using target_type = winrt::graphics::renderer;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.is_rendering();
            }
        };
    };};
    struct list { using type = impl::typelist<named::current_topology, named::current_buffer, named::is_rendering>; };
};

struct property_graphics_shader
{ struct named {
    struct type_glyph
    {
        struct name { static constexpr std::wstring_view value{ L"type_glyph"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::graphics::shader;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.type_glyph();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.type_glyph(std::forward<Value>(value));
            }
        };
    };
    struct shader_type
    {
        struct name { static constexpr std::wstring_view value{ L"shader_type"sv }; };
        using property_type = winrt::graphics::shader_type;
        using target_type = winrt::graphics::shader;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.shader_type();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.shader_type(std::forward<Value>(value));
            }
        };
    };
    struct shader_name
    {
        struct name { static constexpr std::wstring_view value{ L"shader_name"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::graphics::shader;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.shader_name();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.shader_name(std::forward<Value>(value));
            }
        };
    };
    struct is_loading
    {
        struct name { static constexpr std::wstring_view value{ L"is_loading"sv }; };
        using property_type = bool;
        using target_type = winrt::graphics::shader;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.is_loading();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.is_loading(std::forward<Value>(value));
            }
        };
    };
    struct is_error
    {
        struct name { static constexpr std::wstring_view value{ L"is_error"sv }; };
        using property_type = bool;
        using target_type = winrt::graphics::shader;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.is_error();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.is_error(std::forward<Value>(value));
            }
        };
    };};
    struct list { using type = impl::typelist<named::type_glyph, named::shader_type, named::shader_name, named::is_loading, named::is_error>; };
};

struct property_graphics_vertex
{ struct named {
    struct z
    {
        struct name { static constexpr std::wstring_view value{ L"z"sv }; };
        using property_type = float;
        using target_type = winrt::graphics::vertex;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.z();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.z(std::forward<Value>(value));
            }
        };
    };
    struct y
    {
        struct name { static constexpr std::wstring_view value{ L"y"sv }; };
        using property_type = float;
        using target_type = winrt::graphics::vertex;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.y();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.y(std::forward<Value>(value));
            }
        };
    };
    struct x
    {
        struct name { static constexpr std::wstring_view value{ L"x"sv }; };
        using property_type = float;
        using target_type = winrt::graphics::vertex;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.x();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.x(std::forward<Value>(value));
            }
        };
    };
    struct v
    {
        struct name { static constexpr std::wstring_view value{ L"v"sv }; };
        using property_type = float;
        using target_type = winrt::graphics::vertex;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.v();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.v(std::forward<Value>(value));
            }
        };
    };
    struct u
    {
        struct name { static constexpr std::wstring_view value{ L"u"sv }; };
        using property_type = float;
        using target_type = winrt::graphics::vertex;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.u();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.u(std::forward<Value>(value));
            }
        };
    };
    struct r
    {
        struct name { static constexpr std::wstring_view value{ L"r"sv }; };
        using property_type = float;
        using target_type = winrt::graphics::vertex;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.r();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.r(std::forward<Value>(value));
            }
        };
    };
    struct g
    {
        struct name { static constexpr std::wstring_view value{ L"g"sv }; };
        using property_type = float;
        using target_type = winrt::graphics::vertex;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.g();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.g(std::forward<Value>(value));
            }
        };
    };
    struct b
    {
        struct name { static constexpr std::wstring_view value{ L"b"sv }; };
        using property_type = float;
        using target_type = winrt::graphics::vertex;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.b();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.b(std::forward<Value>(value));
            }
        };
    };
    struct a
    {
        struct name { static constexpr std::wstring_view value{ L"a"sv }; };
        using property_type = float;
        using target_type = winrt::graphics::vertex;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.a();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.a(std::forward<Value>(value));
            }
        };
    };};
    struct list { using type = impl::typelist<named::z, named::y, named::x, named::v, named::u, named::r, named::g, named::b, named::a>; };
};

}

WINRT_EXPORT namespace winrt::experimental::reflect {
template <> struct named_property<graphics::Ibuffer> : impl::property_graphics_Ibuffer::named {};
template <> struct properties<graphics::Ibuffer> : impl::property_graphics_Ibuffer::list {};
template <> struct named_property<graphics::Irenderer> : impl::property_graphics_Irenderer::named {};
template <> struct properties<graphics::Irenderer> : impl::property_graphics_Irenderer::list {};
template <> struct named_property<graphics::Ishader> : impl::property_graphics_Ishader::named {};
template <> struct properties<graphics::Ishader> : impl::property_graphics_Ishader::list {};
template <> struct named_property<graphics::Ivertex> : impl::property_graphics_Ivertex::named {};
template <> struct properties<graphics::Ivertex> : impl::property_graphics_Ivertex::list {};
template <> struct named_property<graphics::buffer> : impl::property_graphics_buffer::named {};
template <> struct properties<graphics::buffer> : impl::property_graphics_buffer::list {};
template <> struct named_property<graphics::renderer> : impl::property_graphics_renderer::named {};
template <> struct properties<graphics::renderer> : impl::property_graphics_renderer::list {};
template <> struct named_property<graphics::shader> : impl::property_graphics_shader::named {};
template <> struct properties<graphics::shader> : impl::property_graphics_shader::list {};
template <> struct named_property<graphics::vertex> : impl::property_graphics_vertex::named {};
template <> struct properties<graphics::vertex> : impl::property_graphics_vertex::list {};
template <> struct get_enumerator_names<graphics::buffer_type>
{
    static constexpr std::array<std::wstring_view, 2> value{{ 
        {L"dynamic_buffer", 14},
        {L"static_buffer", 13}, }};
};
template <> struct get_enumerator_values<graphics::buffer_type>
{
    static constexpr std::array<graphics::buffer_type, 2> value{{ 
        graphics::buffer_type::dynamic_buffer,
        graphics::buffer_type::static_buffer, }};
};
template <> struct get_enumerator_names<graphics::primitive_types>
{
    static constexpr std::array<std::wstring_view, 5> value{{ 
        {L"points", 6},
        {L"triangle_list", 13},
        {L"triangle_strips", 15},
        {L"line_lists", 10},
        {L"line_strips", 11}, }};
};
template <> struct get_enumerator_values<graphics::primitive_types>
{
    static constexpr std::array<graphics::primitive_types, 5> value{{ 
        graphics::primitive_types::points,
        graphics::primitive_types::triangle_list,
        graphics::primitive_types::triangle_strips,
        graphics::primitive_types::line_lists,
        graphics::primitive_types::line_strips, }};
};
template <> struct get_enumerator_names<graphics::shader_type>
{
    static constexpr std::array<std::wstring_view, 2> value{{ 
        {L"vertex", 6},
        {L"pixel", 5}, }};
};
template <> struct get_enumerator_values<graphics::shader_type>
{
    static constexpr std::array<graphics::shader_type, 2> value{{ 
        graphics::shader_type::vertex,
        graphics::shader_type::pixel, }};
};

}

WINRT_EXPORT namespace std {

template<> struct hash<winrt::graphics::Ibuffer> : winrt::impl::hash_base<winrt::graphics::Ibuffer> {};
template<> struct hash<winrt::graphics::IbufferFactory> : winrt::impl::hash_base<winrt::graphics::IbufferFactory> {};
template<> struct hash<winrt::graphics::Irenderer> : winrt::impl::hash_base<winrt::graphics::Irenderer> {};
template<> struct hash<winrt::graphics::Ishader> : winrt::impl::hash_base<winrt::graphics::Ishader> {};
template<> struct hash<winrt::graphics::IshaderFactory> : winrt::impl::hash_base<winrt::graphics::IshaderFactory> {};
template<> struct hash<winrt::graphics::Ivertex> : winrt::impl::hash_base<winrt::graphics::Ivertex> {};
template<> struct hash<winrt::graphics::IvertexFactory> : winrt::impl::hash_base<winrt::graphics::IvertexFactory> {};
template<> struct hash<winrt::graphics::buffer> : winrt::impl::hash_base<winrt::graphics::buffer> {};
template<> struct hash<winrt::graphics::renderer> : winrt::impl::hash_base<winrt::graphics::renderer> {};
template<> struct hash<winrt::graphics::shader> : winrt::impl::hash_base<winrt::graphics::shader> {};
template<> struct hash<winrt::graphics::vertex> : winrt::impl::hash_base<winrt::graphics::vertex> {};

}
